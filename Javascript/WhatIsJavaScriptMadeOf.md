# Javascript는 무엇으로 구성되어있을까?  

> `TOAST UI` 사이트를 보며 정리했습니다. 출처는 하단에 있습니다. 

## 값(Value)  
값의 개념은 조금 추상적이다. "것(thing)"이다. 자바스크립트에서 값은 수학의 숫자, 기하학의 점이다. `1`, `2`, `420` 같은 숫자로 된 값 외에, `"은지는 권씨"` 같은 문장도 포함되어 있다. 하지만 모든 것이 값은 아니다. 숫자는 값이지만 if문은 아니다. 

- **값의 타입**: 값에는 몇가지 타입이 존재한다. 예를 들어 420같은 숫자나 "은지는 권씨"같은 문자열, 객체, 그리고 몇 가지 다른 타입이 존재한다. typeof를 값의 앞에 두면 값의 타입에 대해 알 수 있다.   
  ``` javascript
  console.log(typeof 2); // number
  ```
- **원시 값(Primitive Values)**: 몇몇 값들의 타입은 원시(Primitive)다.   
  원시 값은 숫자, 문자열, 그리고 몇 가지 타입을 포함한다.
  원시 값의 한 가지 독특한 점은 새롭게 원시 값을 만들거나, 원시 값을 변경하는 것이 불가능 하다는 것이다. 예를 들어 당신이 `2`를 쓸 때마다 항상 같은 `2` 값을 얻을 것이다. 당신의 프로그램에서 새로운 2를 생성할 수 없고 `2`가 `3`이되는 것은 불가능하다. `문자열` 또한 동일하다.   
- **`null`과 `undefined`**: 두가지 특별한 값이 있다. 이 두 값은 많은 것을 할 수 없게 만들며, 종종 에러의 원인이 된다. 일반적으로 `null`은 의도적으로 값이 없는 것을 의미하며, `undefined`는 의도하지 않게 값이 없는 것을 의미한다. 그러나 언제 어떻게 사용될지는 프로그래머에게 맡겨진다. 두 값은 종종 누락된 값을 처리하는 것보다 연산이 실패하는 것이 괜찮기 때문에 존재한다.  

## 같음(Equality)
"값"처럼, "같음"은 자바스크립트의 기본 개념이다. 두 값이 같다고 말한다면, 같은 값(value)이라는 것을 의미한다. 서로 다른 두 값(value)는 존재할 수 없다. 하나일 뿐이다. 예를 들어, `"은지" === "은지"`나 `2 === 2` 인 것은 `2`는 `2`이기 때문이다. Javascript는 이 개념을 나타내기 위해 등호 3개를 사용한다.  

- **엄격한(strict) 같음**: 위와 동일
- **참조(Referential) 같음**: 위와 동일
- **느슨한(Loose) 같음**: 느슨한 같음은 두 개의 등호(==)를 사용한다.  
  보기에는 비슷해 보이지만 다른 값을 참조하더라도 느슨하게 동등한 것으로 간주할 수 있다. `2(number)와 "2"(string)처럼` 일찍이 자바스크립트에 편의를 위해 추가되었지만, 이후로 끊임없는 혼란을 불러왔다. 이 개념은 기본 개념은 아니지만 일반적인 실수의 원인이 된다. 난관에 부딪혔을 때 상황을 해결해 줄 수 있지만 일반적으로 사용을 지양한다.  

## 리터럴(Literal)
리터럴은 문자를 그대로 적음으로써 값을 나타내는 것이다. `2` 는 숫자 리터럴이고 `"은지"`는 문자열 리터럴이다.  

## 변수
변수를 통해 이름을 사용해 값에 참조할 수 있다.  
예를 들어, 
``` javascript
let message = "은지는 권씨";
``` 
로 작성하면 코드 상에서 반복해서 문장을 적지 않고 `message`로 작성할 수 있게 된다. 또한, 이후에 
``` javascript
message = "난 최고다";
```
처럼 `message`가 다른 값을 가리키도록 바꿀 수 있다. 이것이 의미하는 것은 값 자체를 바꾸는 것이 아니다. 와이어 처럼 `message`가 어디 있는지 가리키는 위치만 변경된다. 변수는 `"은지는 권씨"`를 가리키다, 지금은 `"난 최고다"`를 가리키고 있다.  

- **스코프**: 프로그램 전체에서 하나의 `message` 변수를 사용할 수 있다면 별로일 것이다. 변수를 정의하면, 프로그램의 한 부분에서 사용할 수 있게 된다. 스코프가 어떻게 동작하는지 작동 방식에 대한 규칙이 있지만, 일반적으로 변수를 정의한 위치 근처의 `{`와 `}` 중괄호를 확인하면 찾을 수 있다. 이 코드릐 "블록"이 변수의 스코프다. 
- **할당**: `message = "난 최고다";` 로 작성할 때 message 변수가 가리키는 것이 "난 최고다"로 바뀐다. 이것을 할당, 쓰기, 혹은 변수 설정이라 한다. 
- **`let` vs `const` vs `var`**: 만약 변수에 값 할당을 금지하려면 const를 사용하면 된다. 가능하다면 var 사용은 피해라. var는 스코프를 더럽힌다. 
  내가 정리 해놓은 블로그: https://velog.io/@wow/var-let-const

## 객체
객체는 Javascript에서 특별한 종류의 값이다. 객체의 멋진 점은 다른 값들과 연결을 가질 수 있다는 점이다.   
예를 들어, `{flavor: "vanilla"}` 객체는 `"vanilla"` 라는 값을 가리키는 `flavor` 속성이 존재한다. 객체를 "와이어"로 "자신의" 값을 갖는 값으로 생각하라.  

- **속성**: 속성은 객체에서 어떤 갑승ㄹ 가리키는 "와이어" 역할을 한다.  
  앞에서 언급했던 변수가 떠오를 수 있는데(`flavor` 같은 이름을 갖고 "vanilla"라는 값을 가리키는 것이), 변수와 다르게 요소는 코드(스코프)가 아닌 객체 내에 "존재"하게 된다.  
  요소는 객체의 일부로 간주하지만, 기리키는 값은 아니다.  

- **객체 리터럴**: 객체 리터럴은 `{}`나 `{flavor: "vanilla"}` 처럼 문자 그대로 작성해서 객체를 만드는 방법이다. `{}` 안에는 쉼표로 구분된 여러개의 `{proverty: value}` 쌍을 가질 수 있다. 이를 통해 객체의 속성이 어디에 "와이어"되는지 할당할 수 있다.  
- **객체 항등(Identity)**: 우리는 앞서 `2`는 `2`와 같다(다시 말하면 `2 === 2`)고 했다.    
  왜냐하면 `2`를 작성하는 어디에서나 항상 같은 값이 "소환"되기 때문이다. 하지만 `{}`를 작성한다면, 항상 다른 값이 될 것이다.  
  따라서 `{}`는 다른 `{}`와 다르다. 
  콘솔 창에 `{} === {}` 를 실행하면 false가 반환된다. 
  컴퓨터가 코드에서 `2`를 만나면 항상 같은 `2`를 반환할 것이다. 하지만 객체 리터럴은 다르다.  
  컴퓨터가 `{}`를 만나면 항상 새로운 객체를 생성한다. 그럼 객체 항등(identity)은 무엇일까?  
  그것은 여전히 동일하거나, 값의 동일성을 나타내는 또 다른 용어이다. 우리가 "`a`와 `b`가 같은 값을 가리키고 있다"는 것을 의미한다. (`a === b`) 만약 "`a`와 `b가 항등이 아니다"`라는 것은 "`a`와 `b`가 다른 값을 가리킨다" (`a !== b`)라는 것을 의미한다.  

- **점 표기법**: 객체의 속성에 접근하거나 할당하고 싶을 때 점`.` 표기법을 사용할 수 있다. 
  예를 들어, 변수 `iceCream` 의 `flavor` 요소가 가리키는 값이 `"chocolate"`이라면, `iceCream.flavor` 로 작성할 경우 `"chocolate"`가 반환된다.  

- **괄호 표기법**: 접근하고 싶은 프로퍼티의 이름을 미리 알지 못하는 경우가 있다.  
  예를 들어, 때로는 `iceCream.flavor`에 접근하고 싶을 수도 있고 `iceCream.taste`에 접근하고 싶을 수도 있다. 대괄호 `[]` 표기법은 변수를 이용해서 요소에 접근이 가능하게 한다. 
  예를 들어 `let ourProperty = 'flavor'` 라고 선언해보자.  
  `iceCream[ourProperty]`로 작성하면 `"chocolate"`을 반환한다. 신기하게도 `{ [ourProperty]: "vanilla" }`처럼 객체를 생성할 때도 사용할 수 있다. 

- **뮤테이션(Mutation)**: 우리는 객체의 요소가 가리키는 부분이 달라졌을 때 변이(mutate) 되었다고 한다. 
  예를 들어, `et iceCream = {flavor: "vanilla}` 라고 선언했을 때, `iceCream.flavor = "chocolate"` 으로 작성해 값을 변이할 수 있다. 비록 const로 `iceCream`을 선언하더라도 `iceCream.flavor` 를 통해 변이할 수 있다. 왜냐하면 const는 `iceCream` 변수 그 자체만의 할당만을 막을 수 있기 때문에, 객체의 요소(flavor)가 가리키는 값을 바꿀 수있다. 이런 오해의 소지 때문에 몇몇 사람들은 const를 맹목적으로 잘못 사용하기도 한다.  

- **배열**: 배열은 무엇인가 나열할 때 사용하는 객체이다. 배열 리터럴로 
  ``` javascript
  ["banana", "chocolate", "vanilla"];
  ``` 
  로 작성한다면, 본질적으로   
  `0` 요소: `"banana"`  
  `1` 요소: `"chocolate"`  
  `2` 요소: `"vanilla"` 를 가리키는 객체를 생성한다.  
  `{0: ..., 1: ..., 2: ...}` 처럼 작성하는 것은 매우 귀찮을 것이다. 또한 `map`, `filter`, `reduce`처럼 배열을 다루는 여러가지 메서드 또한 제공된다.  

- **프로토타입**: 만약 존재하지 않는 요소에 접근하려면 어떤 일이 벌어질까?  
  예를 들어 `iceCream.taste` 처럼 말이다. (우리가 선언한 요소는 `flavor` 뿐이다.) 질문에 대한 단순한 답은 `undefined`이다.  
  좀 더 구체적으로 설명해보면, 대부분의 자바스크립트 객체는 "프로토타입"을 갖는다. 당신은 프로토타입을 모든 객체에서 "다음에 어디를 봐야할 지" 결정하는 "숨겨진" 요소로 생각할 수 있다. 따라서 `iceCream` 객체에 `taste`라는 요소가 없다면 javascript는 객체의 프로토 타입을 따라 `taste`를 거슬러 올라갈 것이다.  
  그리고 "프로토타입 체인"을 모두 찾았지만 `.taste`를 찾지 못한 경우에 `undefined`를 반환한다. 당신은 이 메커니즘을 직접적으로 사용할 인은 별로 없겠지만 `iceCream` 객체에 우리가 정의하지 않은 `toString` 메서드가 존재하는 것을 설명할 수 있다. - 이 메서드는 프로토타입에서 왔다.  
  


## 함수
함수는 프로그램에서 일부 코드를 나타내는 목적을 가진 특별한 값이다. 함수는 중복 코드를 여러번 작성하지 않으려는 경우 편리하게 쓸 수 있다.  

`sayHi()` 같은 함수를 "호출" 하면 컴퓨터에서 해당 코드를 내부적으로 실행한 뒤, 프로그램의 원래 위치로 돌아간다.  

- **매개 변수**
- **함수 표현식**
- **함수 호이스팅**
- **this**
- **화살표 함수**
- **함수 바인딩**
- **콜 스텍**
- **재귀** 
- **고차함수(Higher-Order Function)**
- **콜백**
- **클로저** 



출처: https://ui.toast.com/weekly-pick/ko_20200219/